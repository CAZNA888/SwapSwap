# Описание игры SwapSwap - Пазл с механикой свайпов

## Общая концепция

SwapSwap - это 2D игра-пазл, где игрок собирает оригинальное изображение, перемещая карточки свайпами. Особенность игры в том, что карточки могут быть соединены между собой, и игрок может перемещать целые группы соединенных карточек одновременно.

## Основная механика

### 1. Подготовка изображения

- **Исходное изображение** загружается в `GameManager`
- Изображение **разрезается на n×k частей** (настраивается в инспекторе)
- Каждая часть получает **уникальный индекс** (0, 1, 2, ..., n×k-1)
- Индексы соответствуют правильному расположению: `index = row × cols + col`

### 2. Создание карточек

- Создается **n×k карточек** (по количеству частей)
- Каждая карточка содержит:
  - **originalIndex** - правильная позиция в оригинале
  - **currentGridRow/Col** - текущая позиция на игровом поле
  - **frontSprite** - лицевая сторона (кусочек изображения)
  - **backSprite** - обратная сторона (единый спрайт для всех)
  - **borderParts** - 4 части рамки (верх, низ, лево, право)

### 3. Размеры и позиционирование

**Игровое поле:**
- Размер поля: `fieldWidth × fieldHeight` (настраивается)
- Отступы между карточками: `cardSpacing` (настраивается)
- Размер одной карточки: `(fieldWidth/cols - spacing) × (fieldHeight/rows - spacing)`

**Колода:**
- Расположена в **правом нижнем углу** (`deckPosition`)
- Карточки лежат **стопкой** друг на друге
- Все карточки изначально **повернуты спиной**

**Сетка:**
- Левый верхний угол = (0, 0)
- Заполнение: **слева направо, сверху вниз**
- Позиция карточки: `GetWorldPosition(row, col)`

### 4. Последовательность начала игры

1. **Разрезание изображения** → создание массива спрайтов
2. **Создание карточек** → инициализация с индексами
3. **Перемешивание** → случайный порядок размещения
4. **Раздача карточек** → плавное перемещение из колоды на поле (последовательно)
5. **Переворот карточек** → анимация через `scale.x` (1→0→1) с заменой спрайта
6. **Проверка соединений** → обновление границ рамок

### 5. Механика свайпов

**Одиночное перемещение:**
- Игрок нажимает на карточку
- Удерживает палец и перемещает
- При отпускании карточка перемещается в **ближайшую свободную ячейку**

**Групповое перемещение:**
- Если карточки **соединены** (в оригинале стоят рядом И на поле рядом), они перемещаются **вместе**
- Группа сохраняет свою **форму** (относительные позиции)
- Алгоритм поиска группы: **BFS (поиск в ширину)** по соединенным соседям

**Смещение других карточек:**
- После размещения группы, остальные карточки **смещаются в пустые места**
- Смещение происходит **плавно** с анимацией
- Карточки заполняют пустоты **слева направо, сверху вниз**

### 6. Система соединений

**Проверка соединения:**
- Для каждой карточки проверяются **4 стороны** (верх, низ, лево, право)
- Условие соединения:
  1. Карточки **соседи в оригинале** (правильном расположении)
  2. Карточки **соседи на поле** (текущее расположение)
  3. Оба условия выполняются одновременно

**Визуализация:**
- Рамка карточки разрезана на **4 части** (по диагоналям)
- Если карточки соединены → **граница скрывается** (SetActive(false))
- Если не соединены → граница видна
- Проверка происходит **после каждого хода**

**Алгоритм проверки:**
```csharp
// Для карточки A проверяем соседа B:
1. Получить originalIndex A и B
2. Вычислить позиции в оригинале: row = index / cols, col = index % cols
3. Проверить соседство в оригинале (row±1 или col±1)
4. Проверить соседство на поле (currentGridRow/Col)
5. Если оба условия true → соединены
```

### 7. Цель игры

**Победа:**
- Все карточки находятся на **правильных позициях**
- `piece.IsAtCorrectPosition()` возвращает true для всех карточек
- Проверка после каждого хода

**При победе:**
- Звук победы
- Эффект конфетти (заглушка)
- UI "Level Completed"
- Начисление **+15 монеток**
- Кнопка "Next"

### 8. Система монеток

**Начисление:**
- При завершении уровня: **+15 монеток**
- Сохранение в `PlayerPrefs` (ключ: "PlayerMoney")

**Анимация монеток:**
- После нажатия "Next" создаются монетки над кнопкой
- Монетки **плавно перемещаются** к точке `moneyTargetPosition` (где счет денег)
- После анимации вызывается `MoneyManager.AddMoney(15)`

**Отображение:**
- Счет денег отображается на экране
- Обновляется автоматически при изменении

### 9. Звуки

**События со звуками:**
- **Раздача карты** → `cardDealClip` (при каждой карточке)
- **Переворот карты** → `cardFlipClip` (при каждом перевороте)
- **Свайп** → `swipeClip` (при перемещении)
- **Победа** → `levelCompleteClip` (при завершении уровня)

**Формат:** MP3 файлы в папке `Assets/Audio/`

### 10. Структура компонентов

**GameManager** (главный):
- Координирует все системы
- Инициализирует игру
- Проверяет победу

**PuzzleGrid**:
- Управляет сеткой n×k
- Расчет позиций карточек
- Поиск пустых ячеек

**PuzzlePiece**:
- Данные карточки (индекс, позиция, спрайты)
- Состояние (перевернута/не перевернута)

**ImageSlicer**:
- Разрезание спрайта на части
- Создание массива спрайтов с индексами

**CardDealer**:
- Последовательная раздача карточек
- Анимация перемещения (DOTween)

**CardFlipAnimator**:
- Анимация переворота через scale.x
- Замена спрайта в момент scale.x = 0

**SwipeHandler**:
- Обработка свайпов (IPointerDownHandler, IDragHandler, IPointerUpHandler)
- Поиск группы соединенных карточек
- Размещение на сетке

**ConnectionManager**:
- Проверка всех соединений
- Обновление границ рамок

**BorderRenderer**:
- Управление 4 частями рамки
- Включение/выключение границ

**AudioManager**:
- Воспроизведение звуков

**MoneyManager**:
- Управление деньгами
- Сохранение/загрузка из PlayerPrefs

**LevelCompleteUI**:
- UI завершения уровня
- Анимация монеток

**MoneyDisplay**:
- Отображение счета денег

**ConfettiEffect**:
- Заглушка для эффекта конфетти

## Алгоритмы

### Поиск группы соединенных карточек (BFS)

```csharp
List<PuzzlePiece> FindConnectedGroup(PuzzlePiece start) {
    HashSet<PuzzlePiece> visited = new HashSet<PuzzlePiece>();
    Queue<PuzzlePiece> queue = new Queue<PuzzlePiece>();
    queue.Enqueue(start);
    visited.Add(start);
    
    while (queue.Count > 0) {
        PuzzlePiece current = queue.Dequeue();
        foreach (PuzzlePiece neighbor in GetConnectedNeighbors(current)) {
            if (!visited.Contains(neighbor)) {
                visited.Add(neighbor);
                queue.Enqueue(neighbor);
            }
        }
    }
    return visited.ToList();
}
```

### Проверка соединения

```csharp
bool AreConnected(PuzzlePiece a, PuzzlePiece b) {
    // Позиции в оригинале
    Vector2Int aOriginal = a.GetOriginalPosition(gridCols);
    Vector2Int bOriginal = b.GetOriginalPosition(gridCols);
    
    // Соседи в оригинале?
    bool originalAdjacent = (Mathf.Abs(aOriginal.x - bOriginal.x) == 1 && aOriginal.y == bOriginal.y) ||
                           (Mathf.Abs(aOriginal.y - bOriginal.y) == 1 && aOriginal.x == bOriginal.x);
    
    // Соседи на поле?
    bool fieldAdjacent = (Mathf.Abs(a.currentGridRow - b.currentGridRow) == 1 && a.currentGridCol == b.currentGridCol) ||
                        (Mathf.Abs(a.currentGridCol - b.currentGridCol) == 1 && a.currentGridRow == b.currentGridRow);
    
    return originalAdjacent && fieldAdjacent;
}
```

### Размещение группы на сетке

1. Найти ближайшую свободную ячейку для главной карточки
2. Вычислить относительные смещения всех карточек группы
3. Проверить, помещается ли группа начиная с этой ячейки
4. Если нет - найти следующую подходящую позицию
5. Разместить все карточки группы с сохранением формы

### Смещение карточек в пустые места

1. Получить список всех пустых ячеек
2. Получить список карточек, которые нужно сдвинуть (кроме перемещенной группы)
3. Отсортировать карточки и пустые ячейки (сверху вниз, слева направо)
4. Переместить каждую карточку в соответствующую пустую ячейку

## Технические детали

### Зависимости
- **DOTween** - для всех анимаций (уже установлен)
- **Unity 2D** - для спрайтов и физики
- **UI Canvas** - для интерфейса

### Оптимизация
- Object pooling для карточек (можно добавить)
- Кэширование проверок соединений
- Минимизация вызовов Update() - использование событий
- Sprite Atlas для спрайтов

### Система координат
- Левый верхний угол сетки = (0, 0)
- Расчет от центра поля или от левого верхнего угла
- World Space для игрового поля
- Screen Space - Overlay для UI

### Рандомизация
- Перемешивание массива индексов перед раздачей
- Использование `System.Random` для перемешивания

## Настройки в инспекторе

### GameManager
- `sourceImage` - исходное изображение
- `cardBackSprite` - обратная сторона карточки
- `borderSprite` - спрайт рамки
- `gridRows`, `gridCols` - размеры сетки
- `fieldWidth`, `fieldHeight` - размеры поля
- `cardSpacing` - отступы между карточками
- `deckPosition` - позиция колоды
- `moneyTargetPosition` - точка для монеток
- `dealDelay`, `flipDelay` - задержки анимаций

### AudioManager
- `cardDealClip`, `cardFlipClip`, `swipeClip`, `levelCompleteClip` - звуковые клипы
- `volume` - громкость

### LevelCompleteUI
- `levelCompletePanel` - панель завершения
- `levelCompleteText` - текст "Level Completed"
- `nextButton` - кнопка Next
- `coinPrefab` - префаб монетки
- `coinSpawnPoint` - точка спавна монеток
- `coinsToSpawn` - количество монеток (15)

### MoneyDisplay
- `moneyText` - TextMeshProUGUI для отображения денег

## Последовательность работы игры

1. **Start()** → InitializeComponents() → StartGame()
2. **GameSequence()**:
   - SliceImage() → CreatePuzzlePieces() → ShufflePieces()
   - DealCards() → FlipAllCards() → InitializeSwipeHandler()
   - CheckAllConnections()
3. **Игровой процесс**:
   - Игрок свайпает карточки
   - OnPieceMoved() → CheckWinCondition()
   - ConnectionManager.CheckAllConnections() после каждого хода
4. **Победа**:
   - OnLevelComplete() → PlayLevelComplete() → PlayConfetti() → ShowLevelComplete()
   - Нажатие Next → AnimateCoins() → AddMoney(15)

## Важные моменты

1. **Индексация**: `originalIndex = row × cols + col` (одномерная нумерация)
2. **Соединения**: Проверяются только если карточки соседи И в оригинале, И на поле
3. **Группы**: Сохраняют форму при перемещении
4. **Пустые места**: Заполняются автоматически после каждого хода
5. **Проверка победы**: После каждого перемещения карточки
6. **Звуки**: Воспроизводятся при каждом событии
7. **Монетки**: Анимируются только после нажатия Next


